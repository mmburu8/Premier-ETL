# -*- coding: utf-8 -*-
"""JSON PIE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U8qEYK9Epk3miRIpLIfyO1ZsXBdSI7sR
"""

# IMPORTING LIBRARIES
import json
import flatdict
import pandas as pd

# function that will help view components in dictionary
def doraTheExplorer(dignify, n=10):
  dignity = {d: dignify[d] for d in list(dignify)[:n]}
  for dig in dignity:
    ville = dignity[dig]
    print(dig)
    print(type(dig))
    print(ville)
    print(len(ville))
    print("\n")

# function that creates dataframe from dictionary
def dataframeCreator(dicted):
  swarley = pd.DataFrame()
  for jack in dicted:
    jackest = pd.Series(dicted[jack])
    swarley = swarley.append(jackest, ignore_index=True)
  return swarley

def daysDetailsDataframe(dicted):
  # list of outputs
  output = [[], [], [], [], [], [], [], []]
  # list of keys in data["calendar"]["daysWithDetails"]
  joursIdentify = list(dicted.keys())
  for jack in joursIdentify:
    kingz = dicted[jack]
    output[0].append(kingz["day"]["date"])
    output[1].append(kingz["day"]["id"])
    output[2].append(kingz["day"]["userId"])
    champagnePapi = list(kingz["details"]["mealsWithDetails"].keys())
    if champagnePapi == []:
      output[3].append(0)
      output[4].append("None")
      output[5].append(0)
      output[6].append([0])
      output[7].append(["None"])
    else:
      mealId = champagnePapi[0]
      output[3].append(mealId)
      output[4].append(kingz["details"]["mealsWithDetails"][mealId]["meal"]["type"])
      try:
        eventId = kingz["details"]["mealsWithDetails"][mealId]["meal"]["eventId"]
      except KeyError:
        eventId = 0
      output[5].append(eventId)
      dishout = kingz["details"]["mealsWithDetails"][mealId]["details"]["dishes"]
      dishId = list(dishout.keys())
      output[6].append(dishId)
      dishname = [dishout[dish]["name"] for dish in dishId]
      output[7].append(dishname)
  # transform list of lists into dataframe
  daysDetails = pd.DataFrame(output).transpose()
  jourcol = ['Day', 'Day ID', "user ID", "Meal ID", "type", 'event ID', "dishes ID", 'dishes Name']
  daysDetails.columns = jourcol
  # convert string datatype to datetime datatype
  daysDetails["Day"] = pd.to_datetime(daysDetails["Day"])
  # sort values by Day 
  daysDetails.sort_values(by="Day", inplace=True)
  return daysDetails

# functions that forms data["entities"]["events"]["events"] into a dataframe
def eventSquaredDF(luv):
  for u in luv:
    luv[u] = dict(flatdict.FlatDict(luv[u], delimiter="."))
    del luv[u]["mealHasImages"]
    del luv[u]["mealData.mealId"]
    del luv[u]["metadata"]
  org = dataframeCreator(luv)
  org.columns = ["id", "userId", "entityType", "entityId", "ordinal", "hoursSincePrevious"]
  return org

# function that creates dataframes for meal likes and comments
def piaceCommenti(givDict):
  # dataframe for meal Likes
  likesDF = dataframeCreator(givDict["likes"]["likes"])
  # make createdAt into a string datatype
  likesDF = likesDF.astype({"createdAt": str}, errors="raise")
  # datafrma for comments about meals
  commentsDF = dataframeCreator(givDict["comments"]["comments"])
  commentsDF = commentsDF.astype({"createdAt": str}, errors="raise")
  commentsDF.drop("textSrc", axis=1, inplace=True)
  # dataframe for summary of likes
  # place dictionary into variables
  countLikes = givDict["likes"]["aggregates"]["counts"]["meal"]
  mineLikes = givDict["likes"]["aggregates"]["mine"]["meal"]
  # get keys of dictionary countLikes
  countKeys = list(countLikes.keys())
  countant = [countLikes[ck] for ck in countKeys]
  selfie = [mineLikes[ck] for ck in countKeys]
  # create summary likes dataframe
  counts = pd.DataFrame()
  # columns
  counts["mealID"] = countKeys
  counts["Count Likes"] = countant
  counts["Self Likes"] = selfie
  return likesDF, commentsDF, counts

def bindLikesComments(italDict):
  amour = piaceCommenti(italDict)
  # place entityID in list
  entityIdentity = list(amour[2]['mealID'])
  entityIdentity = [int(entity) for entity in entityIdentity]
  # place likes in list
  countlike = list(amour[2]['Count Likes'])
  # place users id that liked meal Id
  userlist = []
  # comments userId list,  comments list
  ziggy = [[], [], []]
  for entity in entityIdentity:
    entDF = pd.DataFrame(amour[0].loc[amour[0]['entityId'] == entity])
    entuser = list(entDF["userId"])
    userlist.append(entuser)
    commDF = pd.DataFrame(amour[1].loc[amour[1]["entityId"] == entity])
    commCount = len(list(commDF["userId"]))
    ziggy[0].append(commCount)
    if commCount == 0:
      ziggy[1].append([0])
      ziggy[2].append(["None"])
    else:
      ziggy[1].append(list(commDF['userId']))
      ziggy[2].append(list(commDF["text"]))
  # insert lists at a specific position in ziggy main list
  ziggy.insert(0, entityIdentity)
  ziggy.insert(1, countlike)
  ziggy.insert(2, userlist)
  # convert list of lists into dataframe
  summary = pd.DataFrame(ziggy).transpose()
  # column names
  summary.columns = ["entityId", "Number of Likes", "userIds Liked", "Number of Comments", "userIds Comments", "Comments"]
  return summary

# modified bindLikesComments
def zeroLikesComments(fils):
  # PLACE ALL ENTITY IDS INTO A LIST
  entIDS = list(fils["events"]["events"])
  # output lists
  output = [[], [], [], [], [], []]
  # view if both likes and comments are zero
  if len(fils["likes"]["likes"]) == 0 and len(fils["comments"]["comments"]) == 0:
    # loop through the entityids
    for ent in entIDS:
      entity = fils["events"]["events"][ent]["entityId"]
      output[0].append(entity)
      output[1].append(0)
      output[2].append([0])
      output[3].append(0)
      output[4].append(0)
      output[5].append(["None"])
  # likes no information and comments have information
  elif len(fils["likes"]["likes"]) == 0 and len(fils["comments"]["comments"]) > 0:
    # dataframe from comments about mealIds
    commentsDF = dataframeCreator(fils["comments"]["comments"])
    commentsDF = commentsDF.astype({"createdAt": str}, errors="raise")
    commentsDF.drop("textSrc", axis=1, inplace=True)
    for ent in entIDS:
      entity = fils["events"]["events"][ent]["entityId"]
      entDF =  pd.DataFrame(commentsDF.loc[commentsDF["entityId"] == float(entity)])
      commCount = len(list(entDF["userId"]))
      output[3].append(commCount)
      if commCount == 0:
        output[4].append([0])
        output[5].append(["None"])
      else:
        output[4].append(list(entDF["userId"]))
        output[5].append(list(entDF["text"]))
      output[0].append(float(entity))
      output[1].append(0)
      output[2].append([0])
  elif len(fils["likes"]["likes"]) > 0 and len(fils["comments"]["comments"]) == 0:
    amourDF = dataframeCreator(fils["likes"]["likes"])
    amourDF = amourDF.astype({"createdAt": str}, errors="raise")
    for ent in entIDS:
      entity = fils["events"]["events"][ent]["entityId"]
      entDF =  pd.DataFrame(amourDF.loc[amourDF["entityId"] == float(entity)])
      amourCount = len(list(entDF["userId"]))
      output[1].append(amourCount)
      if amourCount == 0:
        output[2].append([0])
      else:
        output[2].append(list(entDF["userId"]))
      output[0].append(float(entity))
      output[3].append(0)
      output[4].append([0])
      output[5].append(["None"])
  # transform list of lists into dataframe
  amourCommenti = pd.DataFrame(output).transpose()
  # list of columns
  amourCommenti.columns = ["entityId", "Number of Likes", "userIds Liked", "Number of Comments", "userIds Comments", "Comments"]
  return amourCommenti

# merge dataframes
def matchmaker(events, likecomment):
  vivaVida = ["id", "userId", "entityId"]
  for viva in vivaVida:
    events[viva] = events[viva].map(int)
  totals = pd.merge(events, likecomment, on="entityId", how='outer')
  return totals

# MAIN FUNCTION
def main(fille):
  f = open(fille)
  secondo = json.load(f)
  secondoDays = daysDetailsDataframe(secondo["calendar"]['daysWithDetails'])
  if len(secondo["entities"]["events"]["events"]) == 0:
    naught = fille[:-5]
    trio = [0, naught, None, 0, 0, 0, 0, [0], 0, [0], [None]]
    duty = pd.DataFrame(trio).transpose()
    duty.columns = ["id", "userId", "entityType", "entityId", "ordinal", "hoursSincePrevious", "Number of Likes", "userIds Liked",
                "Number of Comments", "userIds Comments", "Comments"]
    completEvent = duty
  else:
    if len(secondo["entities"]["likes"]["likes"]) == 0 or len(secondo["entities"]["comments"]["comments"]) == 0:
      binders = zeroLikesComments(secondo["entities"])
    else:
      binders = bindLikesComments(secondo['entities'])
    soprano = eventSquaredDF(secondo['entities']['events']['events'])
    completEvent = matchmaker(soprano, binders)
  return secondoDays, completEvent

# list of json files
jason = ["10780.json", "13116.json", "14842.json", "17172.json", "2.json", "20566.json", "21632.json", "2627.json", "7.json",
         "27366.json", "29127.json", "30024.json", "30332.json", "31870.json", "33550.json", "34407.json", "34429.json",
         "36495.json", "37327.json", "38639.json"]
# output lists
output = [[], []]
# loop through json files
for jas in jason:
  # data collection on json file
  truedat = main(jas)
  # schedule date stored here
  output[0].append(truedat[0])
  # summary of events stored 
  output[1].append(truedat[1])
datesScheduled = pd.concat(output[0]).reset_index(drop=True)
eventScheduled = pd.concat(output[1]).reset_index(drop=True)

with pd.ExcelWriter("Engineer Dommie.xlsx") as writer:
  eventScheduled.to_excel(writer, sheet_name = "Events Scheduled")
  datesScheduled.to_excel(writer, sheet_name = "Dates Scheduled")

